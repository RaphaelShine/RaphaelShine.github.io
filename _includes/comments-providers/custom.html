<script>
(function(){
  const API_BASE = "https://wandering-cake-347a.raphaelshine.workers.dev";
  const postId = "{{ page.id | slugify }}";

  const $list = document.getElementById('comment-list');
  const $nick = document.getElementById('nickname');
  const $text = document.getElementById('comment_input');
  const $btn  = document.getElementById('comment-registration');

  // tempId -> item 데이터 (백업용)
  const pendingItems = new Map();

  function escapeHTML(s='') {
    return String(s)
      .replace(/&/g,'&amp;').replace(/</g,'&lt;')
      .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
  }

  function buildCommentLI(item) {
    const { id, title, body, created_at, pending } = item;
    const li = document.createElement('li');
    li.className = 'comment';
    li.dataset.commentId = id || '';
    if (pending) li.dataset.pending = '1';

    const when = created_at ? new Date(created_at).toLocaleString() : '';
    const displayName = escapeHTML(title || '');

    li.innerHTML = `
      <article>
        <header>
          <strong class="comment-author">${displayName}</strong>
          <small class="comment-time">${when}</small>
          ${pending ? '<em class="comment-status"> (등록 중)</em>' : ''}
        </header>
        <div class="content">${escapeHTML(body || '').replace(/\n/g,'<br>')}</div>
      </article>
    `;
    return li;
  }

  function renderReplace(items) {
    // ★ 현재 DOM에 있는 '등록중' 노드를 보존(노드 자체 백업)
    const pendingNodes = Array.from($list.querySelectorAll('li.comment[data-pending="1"]'))
      .map(node => node); // shallow copy

    // 서버 아이템 오래된→최신 정렬
    const ordered = (items || [])
      .slice()
      .sort((a,b)=> new Date(a.created_at) - new Date(b.created_at));

    // 새 목록 그리기
    $list.textContent = '';
    ordered.forEach(it => $list.appendChild(buildCommentLI(it)));

    // ★ 보존해 둔 '등록중' 노드를 그대로 뒤에 다시 붙임(사라질 일 없음)
    pendingNodes.forEach(node => {
      // 혹시 같은 tempId가 이미 서버에 반영되어 있다면(교체되었다면) 중복 방지
      const id = node.dataset.commentId || '';
      const exists = $list.querySelector(`li.comment[data-comment-id="${id}"]`);
      if (!exists) $list.appendChild(node);
    });

    // ★ 백업 Map에 있지만 화면에 없는 pending이 있으면(예외 상황) 새로 만들어서 보강
    for (const [tempId, pi] of pendingItems.entries()) {
      const exists = $list.querySelector(`li.comment[data-comment-id="${tempId}"]`);
      if (!exists) $list.appendChild(buildCommentLI(pi));
    }
  }

  function renderAppend(item) {
    const li = buildCommentLI(item);
    $list.appendChild(li); // 최신이 맨 뒤
    li.scrollIntoView({ block: 'end' });
  }

  function replacePendingWithReal(tempId, realItem) {
    const li = $list.querySelector(`li.comment[data-comment-id="${tempId}"]`);
    if (li) {
      const newLi = buildCommentLI(realItem);
      $list.replaceChild(newLi, li);
      newLi.scrollIntoView({ block: 'end' });
    }
    pendingItems.delete(tempId);
  }

  async function load() {
    const res = await fetch(
      `${API_BASE}/api/comments?postId=${encodeURIComponent(postId)}&ts=${Date.now()}`,
      { cache: 'no-store' }
    );
    const j = await res.json();
    renderReplace(j.items || []);
  }

  async function submit() {
    const title = ($nick.value||'').trim();
    const body  = ($text.value||'').trim();
    if (!title) return alert('닉네임을 입력해주세요!');
    if (!body)  return alert('내용을 입력해주세요!');

    const tempId = `temp-${Date.now()}-${Math.random().toString(36).slice(2)}`;
    const optimisticItem = {
      id: tempId,
      title,
      body,
      created_at: new Date().toISOString(),
      pending: true
    };

    // ① 즉시 맨 뒤에 보이게 + Map에도 보관
    pendingItems.set(tempId, optimisticItem);
    renderAppend(optimisticItem);

    $btn.disabled = true; $btn.textContent = '등록 중...';

    try {
      const res = await fetch(`${API_BASE}/api/comments`, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ title, body, postId })
      });
      const data = await res.json();

      if (!res.ok || data.error) {
        // 실패: 낙관적 항목 제거
        const li = $list.querySelector(`li.comment[data-comment-id="${tempId}"]`);
        if (li) li.remove();
        pendingItems.delete(tempId);
        throw new Error(data.error || '등록 실패');
      }

      // 입력창 초기화
      $nick.value=''; $text.value='';

      // ② 성공: 실제 아이템으로 교체
      if (data.item) {
        replacePendingWithReal(tempId, data.item);
      } else {
        pendingItems.delete(tempId);
        await load();
      }

      // ③ 배경 재동기화(혹시 깃헙 전파 지연 대비) — 보존 로직으로 인해 pending이 지워지지 않음
      load();

    } catch (e) {
      alert(e && e.message ? e.message : '등록 실패');
    } finally {
      $btn.disabled = false; $btn.textContent = '등록';
    }
  }

  document.getElementById('comment-registration').addEventListener('click', submit);
  load();
})();
</script>
