<!-- start custom comments snippet (Google Sign-In: programmatic init) -->
<div id="comments">
  <h3>Comments</h3>

  <!-- 로그인 영역 -->
  <div id="auth-area">
    <!-- 로그인 전 -->
    <div id="login-panel">
      <div id="google-btn"></div>
      <p class="hint" style="margin-top:8px;">댓글을 작성하려면 Google로 로그인하세요.</p>
    </div>
    <!-- 로그인 후 -->
    <div id="me-panel" style="display:none;">
      <img id="me-avatar" alt="" style="width:28px;height:28px;border-radius:50%;vertical-align:middle;">
      <strong id="me-name" style="margin-left:6px;vertical-align:middle;"></strong>
      <button id="logout-btn" style="margin-left:12px;">로그아웃</button>
    </div>
  </div>

  <!-- 닉네임 입력란 제거: 로그인 시 서버가 계정 이름으로 표기 -->
  <textarea id="comment_input" placeholder="내용" maxlength="2000"></textarea>
  <button id="comment-registration">등록</button>

  <ul id="comment-list"></ul>
</div>

<!-- Google Identity Services -->
<script src="https://accounts.google.com/gsi/client" async defer></script>

<script>
(function(){
  const API_BASE = "https://wandering-cake-347a.raphaelshine.workers.dev";
  const postId = "{{ page.id | slugify }}";
  const GOOGLE_CLIENT_ID = "449329975089-rcthfthhp69fpft6o0lcuqtibc0e4is0.apps.googleusercontent.com"; // ★ 너의 Google OAuth Web Client ID로 교체

  // DOM
  const $list = document.getElementById('comment-list');
  const $text = document.getElementById('comment_input');
  const $btn  = document.getElementById('comment-registration');
  const $login = document.getElementById('login-panel');
  const $me = document.getElementById('me-panel');
  const $meName = document.getElementById('me-name');
  const $meAvatar = document.getElementById('me-avatar');
  const $logout = document.getElementById('logout-btn');

  // 로그인 사용자 상태
  let currentUser = null; // {provider, id, name, picture, email?}

  // 낙관적 업데이트 중 보관용
  const pendingItems = new Map();

  // ====== Google Identity Services: programmatic init ======
  // 전역 콜백(필수)
  window.handleGoogleCredentialResponse = async function (response) {
    console.log('[GIS] credential cb', response);
    try {
      const id_token = response && response.credential;
      if (!id_token) throw new Error('Google 인증 토큰 수신 실패');

      const res = await fetch(`${API_BASE}/auth/google`, {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id_token })
      });
      const j = await res.json().catch(()=> ({}));
      if (!res.ok || j.error) throw new Error(j.error || '로그인 실패');

      currentUser = j.user || null;
      console.log('[GIS] login ok', currentUser);
      updateAuthUI();
    } catch (e) {
      console.error(e);
      alert(e && e.message ? e.message : '로그인 실패');
    }
  };

  function initGIS() {
    if (!window.google || !google.accounts || !google.accounts.id) return;
    google.accounts.id.initialize({
      client_id: GOOGLE_CLIENT_ID,
      callback: window.handleGoogleCredentialResponse,
      auto_select: false,
      ux_mode: 'popup'
    });
    const btn = document.getElementById('google-btn');
    if (btn) {
      google.accounts.id.renderButton(btn, {
        type: 'standard',
        theme: 'outline',
        size: 'large',
        shape: 'rectangular',
        text: 'signin_with',
        logo_alignment: 'left'
      });
    }
  }

  // 스크립트 로딩 타이밍 대응(최대 10초 폴링)
  window.addEventListener('load', () => {
    if (window.google && google.accounts && google.accounts.id) {
      initGIS();
    } else {
      const timer = setInterval(() => {
        if (window.google && google.accounts && google.accounts.id) {
          clearInterval(timer);
          initGIS();
        }
      }, 100);
      setTimeout(()=> clearInterval(timer), 10000);
    }
  });

  // ====== 댓글 렌더/유틸 ======
  function escapeHTML(s='') {
    return String(s)
      .replace(/&/g,'&amp;').replace(/</g,'&lt;')
      .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
  }

  function buildCommentLI(item) {
    const { id, title, body, created_at, pending, recent } = item;
    const li = document.createElement('li');
    li.className = 'comment';
    li.dataset.commentId = id || '';
    if (pending) li.dataset.pending = '1';
    if (recent)  li.dataset.recent  = '1';

    const when = created_at ? new Date(created_at).toLocaleString() : '';
    const displayName = escapeHTML(title || ''); // 작성자 = 이슈 제목

    li.innerHTML = `
      <article>
        <header>
          <strong class="comment-author">${displayName}</strong>
          <small class="comment-time">${when}</small>
          ${pending ? '<em class="comment-status"> (등록 중)</em>' : ''}
        </header>
        <div class="content">${escapeHTML(body || '').replace(/\n/g,'<br>')}</div>
      </article>
    `;
    return li;
  }

  function renderReplace(items) {
    const ordered = (items || [])
      .slice()
      .sort((a,b)=> new Date(a.created_at) - new Date(b.created_at)); // 오래된→최신

    const keepNodes = Array.from($list.querySelectorAll('li.comment[data-pending="1"], li.comment[data-recent="1"]'));
    $list.textContent = '';
    ordered.forEach(it => $list.appendChild(buildCommentLI(it)));

    // 보존 노드 복원
    keepNodes.forEach(node => {
      const id = node.dataset.commentId || '';
      const exists = $list.querySelector(`li.comment[data-comment-id="${id}"]`);
      if (!exists) $list.appendChild(node);
    });

    // Map엔 있는데 DOM에 없는 pending 보강
    for (const [tempId, pi] of pendingItems.entries()) {
      const exists = $list.querySelector(`li.comment[data-comment-id="${tempId}"]`);
      if (!exists) $list.appendChild(buildCommentLI(pi));
    }
  }

  async function load() {
    const res = await fetch(
      `${API_BASE}/api/comments?postId=${encodeURIComponent(postId)}&ts=${Date.now()}`,
      { cache: 'no-store', credentials: 'include' }
    );
    const j = await res.json();
    renderReplace(j.items || []);
    return j.items || [];
  }

  function renderAppend(item) {
    const li = buildCommentLI(item);
    $list.appendChild(li);
    li.scrollIntoView({ block: 'end' });
  }

  function markRecentForAWhile(li, ms=10000) {
    li.dataset.recent = '1';
    setTimeout(() => { li.removeAttribute('data-recent'); }, ms);
  }

  function replacePendingWithReal(tempId, realItem) {
    const li = $list.querySelector(`li.comment[data-comment-id="${tempId}"]`);
    if (li) {
      const newLi = buildCommentLI({ ...realItem, recent: true });
      $list.replaceChild(newLi, li);
      newLi.scrollIntoView({ block: 'end' });
      markRecentForAWhile(newLi);
    }
    pendingItems.delete(tempId);
  }

  async function refreshUntilAppears(realId, timeoutMs=10000, intervalMs=1000) {
    const deadline = Date.now() + timeoutMs;
    while (Date.now() < deadline) {
      const items = await load();
      if (items.some(it => String(it.id) === String(realId))) return true;
      await new Promise(r => setTimeout(r, intervalMs));
    }
    return false;
  }

  // ====== 제출 ======
  async function submit() {
    const body  = ($text.value||'').trim();
    if (!currentUser) return alert('로그인이 필요합니다. 먼저 Google로 로그인하세요.');
    if (!body)  return alert('내용을 입력해주세요!');

    const tempId = `temp-${Date.now()}-${Math.random().toString(36).slice(2)}`;
    const optimisticItem = {
      id: tempId,
      // 서버가 title을 세션 기반으로 강제하지만 낙관적으로 사용자명 표시
      title: currentUser.name || 'Google User',
      body,
      created_at: new Date().toISOString(),
      pending: true
    };

    pendingItems.set(tempId, optimisticItem);
    renderAppend(optimisticItem);

    $btn.disabled = true; $btn.textContent = '등록 중...';

    try {
      const res = await fetch(`${API_BASE}/api/comments`, {
        method:'POST',
        credentials: 'include',
        headers:{'Content-Type':'application/json'},
        // 로그인 상태에서는 title을 보내지 않음(서버가 세션으로 설정)
        body: JSON.stringify({ body, postId })
      });
      const data = await res.json();

      if (!res.ok || data.error) {
        const li = $list.querySelector(`li.comment[data-comment-id="${tempId}"]`);
        if (li) li.remove();
        pendingItems.delete(tempId);
        throw new Error(data.error || '등록 실패');
      }

      $text.value='';

      if (data.item) {
        replacePendingWithReal(tempId, data.item);
        refreshUntilAppears(data.item.id).finally(()=>{});
      } else {
        pendingItems.delete(tempId);
        await load();
      }

    } catch (e) {
      console.error(e);
      alert(e && e.message ? e.message : '등록 실패');
    } finally {
      $btn.disabled = false; $btn.textContent = '등록';
    }
  }

  // ====== 로그인 상태 UI ======
  function updateAuthUI() {
    if (currentUser) {
      $login.style.display = 'none';
      $me.style.display = '';
      $meName.textContent = currentUser.name || 'Google User';
      if (currentUser.picture) {
        $meAvatar.src = currentUser.picture;
        $meAvatar.style.display = '';
      } else {
        $meAvatar.style.display = 'none';
      }
    } else {
      $login.style.display = '';
      $me.style.display = 'none';
      $meName.textContent = '';
      $meAvatar.removeAttribute('src');
    }
  }

  async function fetchMe() {
    try {
      const res = await fetch(`${API_BASE}/api/me?ts=${Date.now()}`, {
        method: 'GET',
        credentials: 'include',
        cache: 'no-store'
      });
      const j = await res.json();
      currentUser = j && j.user ? j.user : null;
    } catch {
      currentUser = null;
    } finally {
      updateAuthUI();
    }
  }

  // 이벤트 바인딩
  document.getElementById('comment-registration').addEventListener('click', submit);
  document.getElementById('logout-btn').addEventListener('click', async () => {
    try {
      await fetch(`${API_BASE}/auth/logout`, {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' }
      });
    } catch (e) { /* no-op */ }
    currentUser = null;
    updateAuthUI();
  });

  // 초기: 세션 확인 후 댓글 로드
  fetchMe().then(load);
})();
</script>
<!-- end custom comments snippet -->
