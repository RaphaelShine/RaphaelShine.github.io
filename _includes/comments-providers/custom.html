<!-- start custom comments snippet (Google + GitHub, avatars, badges, meta strip - clean) -->
<div id="comments">
  <h3>Comments</h3>

  <!-- 로그인 영역 -->
  <div id="auth-area" style="margin-bottom: 0.5rem;">
    <!-- 로그인 전 -->
    <div id="login-panel">
      <div id="google-btn" style="display:inline-block;"></div>
      <!-- GitHub 로그인은 리디렉트 방식 -->
      <a
        id="github-login-link"
        class="btn-login-github"
        href="#"
        style="display:inline-block; margin-left:8px; padding:8px 12px; border:1px solid #e5e7eb; border-radius:6px; text-decoration:none; color:#111827; background:#fff;"
      >GitHub로 로그인</a>
      <p class="hint" style="margin:6px 0 0; color:#6b7280; font-size:0.9em;">댓글을 작성하려면 Google 또는 GitHub로 로그인하세요.</p>
    </div>

    <!-- 로그인 후 -->
    <div id="me-panel" style="display:none; margin-bottom:0.25rem;">
      <img id="me-avatar" alt="" style="width:28px;height:28px;border-radius:50%;object-fit:cover;vertical-align:middle;">
      <strong id="me-name" style="margin-left:6px;vertical-align:middle;"></strong>
      <span id="me-provider" class="provider-badge" style="margin-left:8px;"></span>
      <button id="logout-btn" style="margin-left:12px;">로그아웃</button>
    </div>
  </div>

  <textarea id="comment_input" placeholder="내용" maxlength="2000" style="width:100%; min-height:110px;"></textarea>
  <button id="comment-registration" style="margin-top:8px;">등록</button>

  <ul id="comment-list" style="list-style:none; padding-left:0; margin-top:1rem;"></ul>
</div>

<!-- 스타일: 아바타 고정 + 헤더 정렬 + 배지 -->
<style>
  #comments .comment-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
    margin-right: 8px;
    vertical-align: middle;
    flex: 0 0 28px;
  }
  #comments li.comment > article > header {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }
  #comments .comment-author { font-weight: 700; }
  #comments .comment-time { color: #6b7280; font-size: 0.9em; }
  #comments .provider-badge {
    font-size: 0.75em;
    line-height: 1;
    padding: 3px 6px;
    border-radius: 999px;
    background: #eef2ff;
    color: #3949ab;
  }
  #comments .provider-badge.github { background: #f1f5f9; color: #111827; }
  #comments .provider-badge.google { background: #eef7ff; color: #1a73e8; }
  #comments li.comment[data-pending="1"] { opacity: 0.75; }
  #comments li.comment[data-recent="1"]  { outline: 2px solid #e5f1ff; border-radius: 6px; }
</style>

<!-- Google Identity Services -->
<script src="https://accounts.google.com/gsi/client" async defer></script>

<script>
(function(){
  const API_BASE = "https://wandering-cake-347a.raphaelshine.workers.dev";
  const postId = "{{ page.id | slugify }}";
  const RETURN_TO = "{{ page.url | absolute_url }}";
  const GOOGLE_CLIENT_ID = "여기에_구글_Web_Client_ID";

  // DOM
  const $list = document.getElementById('comment-list');
  const $text = document.getElementById('comment_input');
  const $btn  = document.getElementById('comment-registration');
  const $login = document.getElementById('login-panel');
  const $me = document.getElementById('me-panel');
  const $meName = document.getElementById('me-name');
  const $meAvatar = document.getElementById('me-avatar');
  const $meProvider = document.getElementById('me-provider');
  const $logout = document.getElementById('logout-btn');
  const $githubLink = document.getElementById('github-login-link');

  // 상태
  let currentUser = null; // {provider, id, name, picture|avatar_url, ...}
  const pendingItems = new Map();

  // GitHub 로그인 링크
  if ($githubLink) {
    const href = API_BASE + "/auth/login?return_to=" + encodeURIComponent(RETURN_TO);
    $githubLink.setAttribute('href', href);
  }

  // Google Sign-In
  window.handleGoogleCredentialResponse = async function (response) {
    try {
      const id_token = response && response.credential;
      if (!id_token) throw new Error('Google 인증 토큰 수신 실패');
      const res = await fetch(API_BASE + '/auth/google', {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id_token: id_token })
      });
      const j = await res.json().catch(function(){ return {}; });
      if (!res.ok || j.error) throw new Error(j.error || '로그인 실패');
      currentUser = j.user || null;
      updateAuthUI();
    } catch (e) {
      console.error(e);
      alert(e && e.message ? e.message : '로그인 실패');
    }
  };

  function initGIS() {
    if (!window.google || !google.accounts || !google.accounts.id) return;
    google.accounts.id.initialize({
      client_id: GOOGLE_CLIENT_ID,
      callback: window.handleGoogleCredentialResponse,
      auto_select: false,
      ux_mode: 'popup'
    });
    const btn = document.getElementById('google-btn');
    if (btn) {
      google.accounts.id.renderButton(btn, {
        type: 'standard',
        theme: 'outline',
        size: 'large',
        shape: 'rectangular',
        text: 'signin_with',
        logo_alignment: 'left'
      });
    }
  }
  window.addEventListener('load', function () {
    if (window.google && google.accounts && google.accounts.id) {
      initGIS();
    } else {
      const timer = setInterval(function () {
        if (window.google && google.accounts && google.accounts.id) {
          clearInterval(timer);
          initGIS();
        }
      }, 100);
      setTimeout(function(){ clearInterval(timer); }, 10000);
    }
  });

  // 표시 유틸
  function escapeHTML(s) {
    s = s || '';
    return String(s)
      .replace(/&/g,'&amp;').replace(/</g,'&lt;')
      .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
  }

  // 서버 메타 주석 제거 (리터럴 대신 new RegExp 사용)
  function stripSignedMeta(raw) {
    raw = raw || '';
    try {
      var re = new RegExp('<!--\\s*signed_by:\\s*(github|google)\\s*:[^>]*-->', 'gi');
      return String(raw).replace(re, '');
    } catch (e) {
      return String(raw);
    }
  }

  function providerBadgeHTML(provider) {
    if (provider === 'github') return '<span class="provider-badge github">GitHub</span>';
    if (provider === 'google') return '<span class="provider-badge google">Google</span>';
    return '';
  }

  function buildCommentLI(item) {
    const id = item.id;
    const title = item.title;
    const body = item.body;
    const created_at = item.created_at;
    const pending = item.pending;
    const recent = item.recent;
    const author = item.author;

    const li = document.createElement('li');
    li.className = 'comment';
    li.dataset.commentId = id || '';
    if (pending) li.dataset.pending = '1';
    if (recent)  li.dataset.recent  = '1';

    const when = created_at ? new Date(created_at).toLocaleString() : '';
    const displayName = escapeHTML(title || '');
    const provider = author && author.provider ? String(author.provider) : null;
    const badge = providerBadgeHTML(provider);

    const avatarHTML = author && author.avatar_url
      ? '<img class="comment-avatar" src="' + author.avatar_url + '" alt="">'
      : '';

    const safeBody = escapeHTML(stripSignedMeta(body || '')).replace(/\n/g,'<br>');

    li.innerHTML = ''
      + '<article>'
      +   '<header>'
      +     avatarHTML
      +     '<strong class="comment-author">' + displayName + '</strong>'
      +     badge
      +     '<small class="comment-time">' + when + '</small>'
      +     (pending ? '<em class="comment-status"> (등록 중)</em>' : '')
      +   '</header>'
      +   '<div class="content">' + safeBody + '</div>'
      + '</article>';

    return li;
  }

  function renderReplace(items) {
    const ordered = (items || []).slice().sort(function(a,b){
      return new Date(a.created_at) - new Date(b.created_at);
    });

    const keepNodes = Array.from($list.querySelectorAll('li.comment[data-pending="1"], li.comment[data-recent="1"]'));
    $list.textContent = '';
    ordered.forEach(function(it){ $list.appendChild(buildCommentLI(it)); });

    keepNodes.forEach(function(node){
      const id = node.dataset.commentId || '';
      const exists = $list.querySelector('li.comment[data-comment-id="' + id + '"]');
      if (!exists) $list.appendChild(node);
    });

    for (const pair of pendingItems.entries()) {
      const tempId = pair[0];
      const pi = pair[1];
      const exists = $list.querySelector('li.comment[data-comment-id="' + tempId + '"]');
      if (!exists) $list.appendChild(buildCommentLI(pi));
    }
  }

  async function load() {
    const res = await fetch(API_BASE + '/api/comments?postId=' + encodeURIComponent(postId) + '&ts=' + Date.now(), {
      cache: 'no-store',
      credentials: 'include'
    });
    const j = await res.json();
    renderReplace(j.items || []);
    return j.items || [];
  }

  function renderAppend(item) {
    const li = buildCommentLI(item);
    $list.appendChild(li);
    li.scrollIntoView({ block: 'end' });
  }

  function markRecentForAWhile(li, ms) {
    ms = ms || 10000;
    li.dataset.recent = '1';
    setTimeout(function(){ li.removeAttribute('data-recent'); }, ms);
  }

  function replacePendingWithReal(tempId, realItem) {
    const li = $list.querySelector('li.comment[data-comment-id="' + tempId + '"]');
    if (li) {
      const newLi = buildCommentLI(Object.assign({}, realItem, { recent: true }));
      $list.replaceChild(newLi, li);
      newLi.scrollIntoView({ block: 'end' });
      markRecentForAWhile(newLi);
    }
    pendingItems.delete(tempId);
  }

  async function refreshUntilAppears(realId, timeoutMs, intervalMs) {
    timeoutMs = timeoutMs || 10000;
    intervalMs = intervalMs || 1000;
    const deadline = Date.now() + timeoutMs;
    while (Date.now() < deadline) {
      const items = await load();
      if (items.some(function(it){ return String(it.id) === String(realId); })) return true;
      await new Promise(function(r){ setTimeout(r, intervalMs); });
    }
    return false;
  }

  // 제출
  async function submit() {
    const body = ($text.value || '').trim();
    if (!currentUser) { alert('로그인이 필요합니다. 먼저 로그인하세요.'); return; }
    if (!body) { alert('내용을 입력해주세요!'); return; }

    const tempId = 'temp-' + Date.now() + '-' + Math.random().toString(36).slice(2);
    const optimisticItem = {
      id: tempId,
      title: currentUser.name || currentUser.login || 'User',
      body: body,
      created_at: new Date().toISOString(),
      pending: true,
      author: {
        provider: currentUser.provider,
        avatar_url: currentUser.picture || currentUser.avatar_url || ''
      }
    };

    pendingItems.set(tempId, optimisticItem);
    renderAppend(optimisticItem);

    $btn.disabled = true; $btn.textContent = '등록 중...';

    try {
      const res = await fetch(API_BASE + '/api/comments', {
        method:'POST',
        credentials: 'include',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ body: body, postId: postId })
      });
      const data = await res.json();

      if (!res.ok || data.error) {
        const li = $list.querySelector('li.comment[data-comment-id="' + tempId + '"]');
        if (li) li.remove();
        pendingItems.delete(tempId);
        throw new Error(data.error || '등록 실패');
      }

      $text.value='';

      if (data.item) {
        replacePendingWithReal(tempId, data.item);
        refreshUntilAppears(data.item.id).finally(function(){});
      } else {
        pendingItems.delete(tempId);
        await load();
      }

    } catch (e) {
      console.error(e);
      alert(e && e.message ? e.message : '등록 실패');
    } finally {
      $btn.disabled = false; $btn.textContent = '등록';
    }
  }

  // 로그인 상태 UI
  function updateAuthUI() {
    if (currentUser) {
      $login.style.display = 'none';
      $me.style.display = '';
      $meName.textContent = currentUser.name || currentUser.login || 'User';
      $meProvider.textContent = currentUser.provider === 'github' ? 'GitHub' : 'Google';
      $meProvider.className = 'provider-badge ' + (currentUser.provider === 'github' ? 'github' : 'google');

      const av = currentUser.picture || currentUser.avatar_url;
      if (av) {
        $meAvatar.src = av;
        $meAvatar.style.display = '';
      } else {
        $meAvatar.style.display = 'none';
      }
    } else {
      $login.style.display = '';
      $me.style.display = 'none';
      $meName.textContent = '';
      $meAvatar.removeAttribute('src');
      $meProvider.textContent = '';
      $meProvider.className = 'provider-badge';
    }
  }

  async function fetchMe() {
    try {
      const res = await fetch(API_BASE + '/api/me?ts=' + Date.now(), {
        method: 'GET',
        credentials: 'include',
        cache: 'no-store'
      });
      const j = await res.json();
      currentUser = j && j.user ? j.user : null;
    } catch (e) {
      currentUser = null;
    } finally {
      updateAuthUI();
    }
  }

  // 이벤트
  document.getElementById('comment-registration').addEventListener('click', submit);
  document.getElementById('logout-btn').addEventListener('click', async function () {
    try {
      await fetch(API_BASE + '/auth/logout', {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' }
      });
    } catch (e) { /* no-op */ }
    currentUser = null;
    updateAuthUI();
  });

  // 초기: 세션 확인 → 댓글 로드
  fetchMe().then(load);
})();
</script>
<!-- end custom comments snippet -->
