<!-- start custom comments snippet -->
<div id="comments">
  <h3>Comments</h3>
  <input id="nickname" placeholder="닉네임" maxlength="80" />
  <textarea id="comment_input" placeholder="내용" maxlength="2000"></textarea>
  <button id="comment-registration">등록</button>

  <ul id="comment-list"></ul>
</div>

<script>
(function(){
  const API_BASE = "https://wandering-cake-347a.raphaelshine.workers.dev";
  const postId = "{{ page.id | slugify }}";

  const $list = document.getElementById('comment-list');
  const $nick = document.getElementById('nickname');
  const $text = document.getElementById('comment_input');
  const $btn  = document.getElementById('comment-registration');

  // tempId -> item (대기 중인 낙관적 아이템)
  const pendingItems = new Map();

  function escapeHTML(s='') {
    return String(s)
      .replace(/&/g,'&amp;').replace(/</g,'&lt;')
      .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
  }

  function buildCommentLI(item) {
    const { id, title, body, created_at, pending, recent } = item;
    const li = document.createElement('li');
    li.className = 'comment';
    li.dataset.commentId = id || '';
    if (pending) li.dataset.pending = '1';
    if (recent)  li.dataset.recent  = '1';

    const when = created_at ? new Date(created_at).toLocaleString() : '';
    const displayName = escapeHTML(title || ''); // 작성자 = 이슈 제목

    li.innerHTML = `
      <article>
        <header>
          <strong class="comment-author">${displayName}</strong>
          <small class="comment-time">${when}</small>
          ${pending ? '<em class="comment-status"> (등록 중)</em>' : ''}
        </header>
        <div class="content">${escapeHTML(body || '').replace(/\n/g,'<br>')}</div>
      </article>
    `;
    return li;
  }

  function renderReplace(items) {
    const ordered = (items || [])
      .slice()
      .sort((a,b)=> new Date(a.created_at) - new Date(b.created_at)); // 오래된→최신

    // 현재 화면에 있는 '보존 대상' 노드 수집: pending + recent
    const keepNodes = Array.from($list.querySelectorAll('li.comment[data-pending="1"], li.comment[data-recent="1"]'));

    $list.textContent = '';
    ordered.forEach(it => $list.appendChild(buildCommentLI(it)));

    // 보존 노드 복원 (서버 목록에 아직 안 뜨더라도 지우지 않음)
    keepNodes.forEach(node => {
      const id = node.dataset.commentId || '';
      const exists = $list.querySelector(`li.comment[data-comment-id="${id}"]`);
      if (!exists) $list.appendChild(node);
    });

    // Map엔 있는데 DOM에 없는 pending이 있으면 보강
    for (const [tempId, pi] of pendingItems.entries()) {
      const exists = $list.querySelector(`li.comment[data-comment-id="${tempId}"]`);
      if (!exists) $list.appendChild(buildCommentLI(pi));
    }
  }

  async function load() {
    const res = await fetch(
      `${API_BASE}/api/comments?postId=${encodeURIComponent(postId)}&ts=${Date.now()}`,
      { cache: 'no-store' }
    );
    const j = await res.json();
    renderReplace(j.items || []);
    return j.items || [];
  }

  function renderAppend(item) {
    const li = buildCommentLI(item);
    $list.appendChild(li); // 최신이 맨 뒤
    li.scrollIntoView({ block: 'end' });
  }

  function markRecentForAWhile(li, ms=10000) {
    // 성공 직후 일정 시간 보존되도록 recent 마크
    li.dataset.recent = '1';
    setTimeout(() => { li.removeAttribute('data-recent'); }, ms);
  }

  function replacePendingWithReal(tempId, realItem) {
    const li = $list.querySelector(`li.comment[data-comment-id="${tempId}"]`);
    if (li) {
      const newLi = buildCommentLI({ ...realItem, recent: true });
      $list.replaceChild(newLi, li);
      newLi.scrollIntoView({ block: 'end' });
      // recent 보존 타이머
      markRecentForAWhile(newLi);
    }
    pendingItems.delete(tempId);
  }

  // 서버 목록에 특정 id가 나타날 때까지 '새로고침하듯' 재시도
  async function refreshUntilAppears(realId, timeoutMs=10000, intervalMs=1000) {
    const deadline = Date.now() + timeoutMs;
    while (Date.now() < deadline) {
      const items = await load();
      if (items.some(it => String(it.id) === String(realId))) return true;
      await new Promise(r => setTimeout(r, intervalMs));
    }
    return false; // 타임아웃
  }

  async function submit() {
    const title = ($nick.value||'').trim();
    const body  = ($text.value||'').trim();
    if (!title) return alert('닉네임을 입력해주세요!');
    if (!body)  return alert('내용을 입력해주세요!');

    const tempId = `temp-${Date.now()}-${Math.random().toString(36).slice(2)}`;
    const optimisticItem = {
      id: tempId, title, body,
      created_at: new Date().toISOString(),
      pending: true
    };

    // 즉시 맨 뒤에 보이게 + Map에도 보관
    pendingItems.set(tempId, optimisticItem);
    renderAppend(optimisticItem);

    $btn.disabled = true; $btn.textContent = '등록 중...';

    try {
      const res = await fetch(`${API_BASE}/api/comments`, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ title, body, postId })
      });
      const data = await res.json();

      if (!res.ok || data.error) {
        // 실패: 낙관적 항목 제거
        const li = $list.querySelector(`li.comment[data-comment-id="${tempId}"]`);
        if (li) li.remove();
        pendingItems.delete(tempId);
        throw new Error(data.error || '등록 실패');
      }

      // 입력창 초기화
      $nick.value=''; $text.value='';

      // 성공: 실제 아이템으로 교체 + recent 보존
      if (data.item) {
        replacePendingWithReal(tempId, data.item);

        // 새로고침하듯: 서버 목록에 나타날 때까지 폴링(최대 10초)
        refreshUntilAppears(data.item.id).finally(()=>{ /* no-op */ });
      } else {
        // 안전망: item이 없으면 전체 새로고침
        pendingItems.delete(tempId);
        await load();
      }

    } catch (e) {
      alert(e && e.message ? e.message : '등록 실패');
    } finally {
      $btn.disabled = false; $btn.textContent = '등록';
    }
  }

  document.getElementById('comment-registration').addEventListener('click', submit);
  load();
})();
</script>


<!-- end custom comments snippet -->
